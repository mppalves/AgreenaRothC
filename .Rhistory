wth <- get_wth_power_nasa(lonlat = lonlat, dates = wth_dates)
soil <- get_isric_soil_profile(lonlat, statistic = "mean", find.location.name = FALSE)
# inorganic Carbon
iom <- 0.049 * (soil$Carbon^(1.139))
# weather distributions
nsamples <- 5
TS <- apply(wth[, c("TS_AV", "TS_SD")], 1, function(x) rnorm(nsamples, x["TS_AV"], x["TS_SD"]))
PR <- apply(wth[, c("PRECTOTCORR_AV", "PRECTOTCORR_SD")], 1, function(x) rnorm(nsamples, x["PRECTOTCORR_SD"], x["PRECTOTCORR_SD"]))
ET <- apply(wth[, c("EVPTRNS_AV", "EVPTRNS_SD")], 1, function(x) rnorm(nsamples, x["EVPTRNS_AV"], x["EVPTRNS_SD"]))
wth_dist <- array(c(TS, PR, ET), dim = c(nsamples, 12, 3), dimnames = list(1:nsamples, month.name, c("TS", "PR", "ET")))
# flow rate effects distribution (baseline)
ft_b <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
fw_b <- t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) f_moist_rothc(pp = x[, "PR"], et = x[, "ET"] / 0.1, s_thick = 30, pclay = mean(soil$ParticleSizeClay[1:3]), pE = 1.0, soil_cover = cp_b)))
colnames(fw_s) <- month.name
fxi_b <- fw_b * ft_b
# flow rate effects distribution (scenario)
ft_s <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
fw_s <- t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) f_moist_rothc(pp = x[, "PR"], et = x[, "ET"] / 0.1, s_thick = 30, pclay = mean(soil$ParticleSizeClay[1:3]), pE = 1.0, soil_cover = cp_s)))
colnames(fw_s) <- month.name
fxi_s <- fw_s * ft_s
fxi_all <- array(c(fxi_b, fxi_s), dim = c(nsamples, 12, 2), dimnames = list(1:nsamples, month.name, c("baseline", "scenario")))
run_RothC <- function(x, trm_b, trm_s, inp_b, inp_s, spin_period, sim_period) {
trm_spin <- trm_b
# inp_spin <- inp_b
soilC_calib <- function(inp_calib) {
fxi_calib <- data.frame(spin_period, rep(x[, "baseline"], length.out = length(spin_period)))
trm_calib <- trm_b
model_calib <- RothCModel(
t = spin_period,
c(k.DPM = 10 * trm_spin, k.RPM = 0.3 * trm_spin, k.BIO = 0.66 * trm_spin, k.HUM = 0.02 * trm_spin, k.IOM = 0 * trm_spin),
C0 = c(DPM = 0, RPM = 0, BIO = 0, HUM = 0, IOM = sum(iom[1:3])),
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_calib
)
soilC_calib <- sum(as.numeric(tail(getC(model_calib), 1)))
return((sum(soilC_calib) - sum(soil$Carbon[c(1, 2, 3)]))^2)
}
inp_calib <- optimize(f = soilC_calib, c(0, 50))$minimum
fxi_spin <- data.frame(spin_period, rep(x[, "baseline"], length.out = length(spin_period)))
model_spin <- RothCModel(
t = spin_period,
c(k.DPM = 10 * trm_spin, k.RPM = 0.3 * trm_spin, k.BIO = 0.66 * trm_spin, k.HUM = 0.02 * trm_spin, k.IOM = 0 * trm_spin),
C0 = c(DPM = 0, RPM = 0, BIO = 0, HUM = 0, IOM = sum(iom[1:3])),
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_spin
)
soilC_spin_all_time <- getC(model_spin)
soilC_spin <- as.numeric(tail(soilC_spin_all_time, 1))
fxi_b <- data.frame(sim_period, rep(x[, "baseline"], length.out = length(sim_period)))
model_b <- RothCModel(
t = sim_period,
c(k.DPM = 10 * trm_b, k.RPM = 0.3 * trm_b, k.BIO = 0.66 * trm_b, k.HUM = 0.02 * trm_b, k.IOM = 0 * trm_b),
C0 = soilC_spin,
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_b
)
soilC_b_all_time <- getC(model_b)
soilC_b <- as.numeric(tail(soilC_b_all_time, 1))
fxi_s <- data.frame(sim_period, rep(x[, "scenario"], length.out = length(sim_period)))
model_s <- RothCModel(
t = sim_period,
c(k.DPM = 10 * trm_s, k.RPM = 0.3 * trm_s, k.BIO = 0.66 * trm_s, k.HUM = 0.02 * trm_s, k.IOM = 0 * trm_s),
C0 = soilC_spin,
In = inp_s,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_s
)
soilC_s_all_time <- getC(model_s)
soilC_s <- as.numeric(tail(soilC_s_all_time, 1))
res <- list("sc_diff" = sum(soilC_s) - sum(soilC_b), "inp_calib" = inp_calib, "sc_spinup" = soilC_spin_all_time, "sc_baseline" = soilC_b_all_time, "sc_scenario" = soilC_s_all_time)
return(res)
}
RothC_runs <- apply(fxi_all, 1, run_RothC, trm_b = trm_b, trm_s = trm_s, inp_b = inp_b, inp_s = inp_s, spin_period = spin_period, sim_period = sim_period)
# Cleaning up and calc statistics
Mean_capture <- mean(unlist(sapply(RothC_runs, "[", "sc_diff")))
Std_dev <- sd(unlist(sapply(RothC_runs, "[", "sc_diff")))
mscc <- sapply(RothC_runs, "[", "sc_spinup")
mscc <- array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_su <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_su) <- c("DPM_SU", "RPM_SU", "BIO_SU", "HUM_SU", "IOM_SU", "DPM_SU_SD", "RPM_SU_SD", "BIO_SU_SD", "HUM_SU_SD", "IOM_SU_SD")
mscc <- sapply(RothC_runs, "[", "sc_spinup")
mscc <- array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_su <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_su) <- c("SC_SU", "SC_SU_SD")
mscc_stats_su <- cbind(mscc_stats_su, mscc_stats_total_su)
mscc <- sapply(RothC_runs, "[", "sc_baseline")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_b <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_b) <- c("DPM_B", "RPM_B", "BIO_B", "HUM_B", "IOM_B", "DPM_B_SD", "RPM_B_SD", "BIO_B_SD", "HUM_B_SD", "IOM_B_SD")
mscc <- sapply(RothC_runs, "[", "sc_baseline")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_b <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_b) <- c("SC_B", "SC_B_SD")
mscc_stats_b <- cbind(mscc_stats_b, mscc_stats_total_b)
mscc <- sapply(RothC_runs, "[", "sc_scenario")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_s <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_s) <- c("DPM_S", "RPM_S", "BIO_S", "HUM_S", "IOM_S", "DPM_S_SD", "RPM_S_SD", "BIO_S_SD", "HUM_S_SD", "IOM_S_SD")
mscc <- sapply(RothC_runs, "[", "sc_scenario")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_s <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_s) <- c("SC_S", "SC_S_SD")
mscc_stats_s <- cbind(mscc_stats_s, mscc_stats_total_s)
res <- list("Mean_capture" = Mean_capture, "Std_dev" = Std_dev, "soilC_spinup" = mscc_stats_su, "soilC_baseline" = mscc_stats_b, "soilC_scenario" = mscc_stats_s)
attr(res, "Unit") <- "C Mg/ha"
return(res)
}
lonlat <- c(9.302144386852655, 56.5691426133239)
sim_period <- c("2022-01-01", "2050-12-30")
wth <- get_wth_power_nasa(lonlat = lonlat, dates = dates)
dates <- c("1990-01-01", "2020-12-30")
wth <- get_wth_power_nasa(lonlat = lonlat, dates = dates)
plotWth(wth)
lonlat
sim_period
biomass_inputs
a <- AgreenaRothC(lonlat, sim_period, inp_s = 0.2, cp_b = T, cp_s = T, till_b = "Till", till_s = "Till")
#' @title Agreena RothC
#' @description Calculates soil carbon stocks for the RothC spin up period, baseline and scenario runs.
#' @name get_wth_power_nasa
#' @param lonlat Longitude and latitude vector
#' @param sim_period Simulating period
#' @param inp_b Biomass inputs in the baseline scenario
#' @param inp_s Biomass inputs in the test scenario
#' @param cp_b Logical vector with months where the soil is covered. If only a single value is passed the whole period will be treated homogeneously.
#' @param cp_s date ranges
#' @param till_b date ranges
#' @param till_s date ranges
#' @return returns a data frame with average (AV) and standard deviation (SD) of surface temperature (TS), bias corrected precipitation (PRECTOTCORR) and Evapotranspiration Energy Flux (EVPTRNS).
#' @details Agreena RothC initializes RothC biomass inputs by inverse modeling to calibrate total soil carbon stocks with estimates generated by ISRIC soilgrids.
#' The estimates biomass inputs are used to spin up the model until soil carbon stocks equilibrium is reached for each soil carbon compartment. Those values are then used to initialize Baseline and scenario runs.
#' @author Marcos Alves
#' @import SoilR stats
#' @export
#'
AgreenaRothC <- function(lonlat, sim_period, inp_b = 1.7, inp_s = 1.7, cp_b = FALSE, cp_s = TRUE,
till_b = c("Till", "noTill", "redTill"), till_s = c("Till", "noTill", "redTill")) {
set.seed(123)
till_b <- match.arg(till_b)
till_s <- match.arg(till_s)
trm_b <- switch(till_b,
"Till" = 1,
"noTill" = 0.95,
"redTill" = 0.93
)
trm_s <- switch(till_s,
"Till" = 1,
"noTill" = 0.95,
"redTill" = 0.93
)
# translating perior in RothC months
years <- round(as.numeric(as.Date(sim_period[2]) - as.Date(sim_period[1])) / 365)
sim_period <- seq(1 / 12, years, by = 1 / 12)
spin_period <- seq(1 / 12, 400, by = 1 / 12)
# downloading external input data
wth_dates <- c("1990-01-01", "2021-12-30")
wth <- get_wth_power_nasa(lonlat = lonlat, dates = wth_dates)
soil <- get_isric_soil_profile_rothc(lonlat, statistic = "mean", find.location.name = TRUE)
# inorganic Carbon
iom <- 0.049 * (soil$Carbon^(1.139))
# weather distributions
nsamples <- 5
TS <- apply(wth[, c("TS_AV", "TS_SD")], 1, function(x) rnorm(nsamples, x["TS_AV"], x["TS_SD"]))
PR <- apply(wth[, c("PRECTOTCORR_AV", "PRECTOTCORR_SD")], 1, function(x) rnorm(nsamples, x["PRECTOTCORR_SD"], x["PRECTOTCORR_SD"]))
ET <- apply(wth[, c("EVPTRNS_AV", "EVPTRNS_SD")], 1, function(x) rnorm(nsamples, x["EVPTRNS_AV"], x["EVPTRNS_SD"]))
wth_dist <- array(c(TS, PR, ET), dim = c(nsamples, 12, 3), dimnames = list(1:nsamples, month.name, c("TS", "PR", "ET")))
# flow rate effects distribution (baseline)
ft_b <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
fw_b <- t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) f_moist_rothc(pp = x[, "PR"], et = x[, "ET"] / 0.1, s_thick = 30, pclay = mean(soil$ParticleSizeClay[1:3]), pE = 1.0, soil_cover = cp_b)))
colnames(fw_b) <- month.name
fxi_b <- fw_b * ft_b
# flow rate effects distribution (scenario)
ft_s <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
fw_s <- t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) f_moist_rothc(pp = x[, "PR"], et = x[, "ET"] / 0.1, s_thick = 30, pclay = mean(soil$ParticleSizeClay[1:3]), pE = 1.0, soil_cover = cp_s)))
colnames(fw_s) <- month.name
fxi_s <- fw_s * ft_s
fxi_all <- array(c(fxi_b, fxi_s), dim = c(nsamples, 12, 2), dimnames = list(1:nsamples, month.name, c("baseline", "scenario")))
run_RothC <- function(x, trm_b, trm_s, inp_b, inp_s, spin_period, sim_period) {
trm_spin <- trm_b
# inp_spin <- inp_b
soilC_calib <- function(inp_calib) {
fxi_calib <- data.frame(spin_period, rep(x[, "baseline"], length.out = length(spin_period)))
trm_calib <- trm_b
model_calib <- RothCModel(
t = spin_period,
c(k.DPM = 10 * trm_spin, k.RPM = 0.3 * trm_spin, k.BIO = 0.66 * trm_spin, k.HUM = 0.02 * trm_spin, k.IOM = 0 * trm_spin),
C0 = c(DPM = 0, RPM = 0, BIO = 0, HUM = 0, IOM = sum(iom[1:3])),
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_calib
)
soilC_calib <- sum(as.numeric(tail(getC(model_calib), 1)))
return((sum(soilC_calib) - sum(soil$Carbon[c(1, 2, 3)]))^2)
}
inp_calib <- optimize(f = soilC_calib, c(0, 50))$minimum
fxi_spin <- data.frame(spin_period, rep(x[, "baseline"], length.out = length(spin_period)))
model_spin <- RothCModel(
t = spin_period,
c(k.DPM = 10 * trm_spin, k.RPM = 0.3 * trm_spin, k.BIO = 0.66 * trm_spin, k.HUM = 0.02 * trm_spin, k.IOM = 0 * trm_spin),
C0 = c(DPM = 0, RPM = 0, BIO = 0, HUM = 0, IOM = sum(iom[1:3])),
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_spin
)
soilC_spin_all_time <- getC(model_spin)
soilC_spin <- as.numeric(tail(soilC_spin_all_time, 1))
fxi_b <- data.frame(sim_period, rep(x[, "baseline"], length.out = length(sim_period)))
model_b <- RothCModel(
t = sim_period,
c(k.DPM = 10 * trm_b, k.RPM = 0.3 * trm_b, k.BIO = 0.66 * trm_b, k.HUM = 0.02 * trm_b, k.IOM = 0 * trm_b),
C0 = soilC_spin,
In = inp_calib,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_b
)
soilC_b_all_time <- getC(model_b)
soilC_b <- as.numeric(tail(soilC_b_all_time, 1))
fxi_s <- data.frame(sim_period, rep(x[, "scenario"], length.out = length(sim_period)))
model_s <- RothCModel(
t = sim_period,
c(k.DPM = 10 * trm_s, k.RPM = 0.3 * trm_s, k.BIO = 0.66 * trm_s, k.HUM = 0.02 * trm_s, k.IOM = 0 * trm_s),
C0 = soilC_spin,
In = inp_s,
clay = mean(soil$ParticleSizeClay[1:3]),
xi = fxi_s
)
soilC_s_all_time <- getC(model_s)
soilC_s <- as.numeric(tail(soilC_s_all_time, 1))
res <- list("sc_diff" = sum(soilC_s) - sum(soilC_b), "inp_calib" = inp_calib, "sc_spinup" = soilC_spin_all_time, "sc_baseline" = soilC_b_all_time, "sc_scenario" = soilC_s_all_time)
return(res)
}
RothC_runs <- apply(fxi_all, 1, run_RothC, trm_b = trm_b, trm_s = trm_s, inp_b = inp_b, inp_s = inp_s, spin_period = spin_period, sim_period = sim_period)
# Cleaning up and calc statistics
Mean_capture <- mean(unlist(sapply(RothC_runs, "[", "sc_diff")))
Std_dev <- sd(unlist(sapply(RothC_runs, "[", "sc_diff")))
mscc <- sapply(RothC_runs, "[", "sc_spinup")
mscc <- array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_su <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_su) <- c("DPM_SU", "RPM_SU", "BIO_SU", "HUM_SU", "IOM_SU", "DPM_SU_SD", "RPM_SU_SD", "BIO_SU_SD", "HUM_SU_SD", "IOM_SU_SD")
mscc <- sapply(RothC_runs, "[", "sc_spinup")
mscc <- array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_su <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_su) <- c("SC_SU", "SC_SU_SD")
mscc_stats_su <- cbind(mscc_stats_su, mscc_stats_total_su)
mscc <- sapply(RothC_runs, "[", "sc_baseline")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_b <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_b) <- c("DPM_B", "RPM_B", "BIO_B", "HUM_B", "IOM_B", "DPM_B_SD", "RPM_B_SD", "BIO_B_SD", "HUM_B_SD", "IOM_B_SD")
mscc <- sapply(RothC_runs, "[", "sc_baseline")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_b <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_b) <- c("SC_B", "SC_B_SD")
mscc_stats_b <- cbind(mscc_stats_b, mscc_stats_total_b)
mscc <- sapply(RothC_runs, "[", "sc_scenario")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_mean <- apply(mscc, c(1, 2), mean)
mscc_sd <- apply(mscc, c(1, 2), sd)
mscc_stats_s <- as.data.frame(cbind(mscc_mean, mscc_sd))
colnames(mscc_stats_s) <- c("DPM_S", "RPM_S", "BIO_S", "HUM_S", "IOM_S", "DPM_S_SD", "RPM_S_SD", "BIO_S_SD", "HUM_S_SD", "IOM_S_SD")
mscc <- sapply(RothC_runs, "[", "sc_scenario")
mscc <- array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
mscc_total <- apply(mscc, c(1, 3), sum)
mscc_total_mean <- apply(mscc_total, 1, mean)
mscc_total_sd <- apply(mscc_total, 1, sd)
mscc_stats_total_s <- as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
colnames(mscc_stats_total_s) <- c("SC_S", "SC_S_SD")
mscc_stats_s <- cbind(mscc_stats_s, mscc_stats_total_s)
res <- list("Mean_capture" = Mean_capture, "Std_dev" = Std_dev, "soilC_spinup" = mscc_stats_su, "soilC_baseline" = mscc_stats_b, "soilC_scenario" = mscc_stats_s)
attr(res, "Unit") <- "C Mg/ha"
return(res)
}
a <- AgreenaRothC(lonlat, sim_period, inp_s = 0.2, cp_b = T, cp_s = T, till_b = "Till", till_s = "Till")
#' Source: https://www.isric.org/ \cr
#' Details: https://www.isric.org/explore/soilgrids/faq-soilgrids \cr
#'
#' @title Download a soil profile from the ISRIC soil database
#' @description Retrieves soil data from the ISRIC global database and converts it to a data frame that can be used to run RothC
#' @name get_isric_soil_profile_rothc
#' @param lonlat Longitude and latitude vector (e.g. c(-93, 42)).
#' @param statistic default is the mean
#' @param find.location.name default is TRUE. Use either maps package or photon API to find Country/State.
#' If you are running this function many times it might be better to set this to FALSE.
#' @return data frame with soil characteristics and \code{meta} Attributes.
#' @details Variable which are directly retrieved and a simple unit conversion is performed: \cr
#' * Bulk density - bdod \cr
#' * Carbon - soc \cr
#' * Clay - clay \cr
#' * Sand - sand \cr
#' * Silt - silt \cr
#' @seealso \code{\link{apsimx_soil_profile}}, \code{\link{edit_apsim_replace_soil_profile}}, \code{\link{edit_apsimx_replace_soil_profile}}.
#' @export
#' @author Marcos Alves (Modified from: Fernando E. Miguez)
#' @examples
#' \dontrun{
#' ## Get soil profile properties for a single point
#' sp1 <- get_isric_soil_profile_rothc(lonlat = c(-93, 42))
#' sp1
#'
#'
#' }
get_isric_soil_profile_rothc <- function(lonlat,
statistic = c("mean", "Q0.5"),
find.location.name = TRUE){
statistic <- match.arg(statistic)
#### Create extent step ####
lon <- as.numeric(lonlat[1])
lat <- as.numeric(lonlat[2])
if(lon < -180 || lon > 180) stop("longitude should be between -180 and 180")
if(lat < -90 || lat > 90) stop("latitude should be between -90 and 90")
##  rest0 <- "https://rest.soilgrids.org/soilgrids/v2.0/properties/query?lon="
rest0 <- "https://rest.isric.org/soilgrids/v2.0/properties/query?lon="
rest1 <- paste0(rest0, lon, "&lat=", lat)
rest.properties <- paste("&property=bdod",
"property=soc",
"property=clay",
"property=sand",
"property=silt", sep = "&")
rest.depths <- paste("&depth=0-5cm", "depth=0-30cm", "depth=5-15cm",
"depth=15-30cm", "depth=30-60cm", "depth=60-100cm", "depth=100-200cm", sep = "&")
rest.statistic <- paste("&value", statistic, sep = "=")
rest.query <- paste0(rest1, rest.properties, rest.depths, rest.statistic)
rest.data <- jsonlite::fromJSON(rest.query)
#### Process query
sp.nms <- rest.data$properties$layers[["name"]]
if(!all(sp.nms %in% c("bdod", "soc", "clay", "sand", "silt"))){
cat("Found these properties", sp.nms, "\n")
cat("Expected these properties", c("bdod", "soc", "clay", "sand", "silt"), "\n")
stop("soil properties names do not match")
}
bdod <- rest.data$properties$layers[1,3][[1]][,3]
clay <- rest.data$properties$layers[2,3][[1]][,3]
sand <- rest.data$properties$layers[3,3][[1]][,3]
silt <- rest.data$properties$layers[4,3][[1]][,3]
soc <- rest.data$properties$layers[5,3][[1]][,3]
if(any(is.na(soc))) stop("No soil data available for this location. Did you specify the coordinates correctly?")
### For some of the conversions see: https://www.isric.org/explore/soilgrids/faq-soilgrids
soil_profile <- NULL
soil_profile$layers <- rest.data$properties$layers[1,3][[1]][2]
soil_profile$BD <- bdod[[1]] * 1e-2
soil_profile$Carbon <- soc[[1]] * 1e-2
soil_profile$ParticleSizeClay <- clay[[1]] * 1e-1
soil_profile$ParticleSizeSand <- sand[[1]] * 1e-1
soil_profile$ParticleSizeSilt <- silt[[1]] * 1e-1
soil_profile <- as.data.frame(soil_profile)
#### Passing parameters from soilwat
## The soil texture class will be based on the first layer only
txt_clss <- texture_class(soil_profile$ParticleSizeClay[1] * 1e-2, soil_profile$ParticleSizeSilt[1] * 1e-2)
if(find.location.name){
if(requireNamespace("maps", quietly = TRUE)){
country <- maps::map.where(x = lon, y = lat)
if(country == "USA"){
state <- toupper(maps::map.where(database = "county", x = lon, y = lat))
}else{
url <- paste0("https://photon.komoot.io/reverse?lon=", lon, "&lat=", lat)
fgeo <- jsonlite::fromJSON(url)
state <- fgeo$feature$properties$state
}
}else{
url <- paste0("https://photon.komoot.io/reverse?lon=", lon, "&lat=", lat)
fgeo <- jsonlite::fromJSON(url)
state <- fgeo$feature$properties$state
country <- fgeo$features$properties$country
}
} else {
state <- NULL
country <- NULL
}
#### Attributes ####
alist <- list()
alist$SoilType <- paste("SoilType = ", txt_clss)
alist$State <- state
alist$Country <- country
alist$Longitude <- lon
alist$Latitude <- lat
alist$DataSource <- paste("Original source is www.isric.org. See: https://www.isric.org/explore/soilgrids/faq-soilgrids ",Sys.time())
alist$Comments <- paste("resolution = 250m",
"- taxonomic classification name =", txt_clss)
attr(soil_profile, "meta") <- alist
return(soil_profile)
}
## Potentially useful function provided by Eric Zurcher
## written by Andrew Moore
## I think the values should be in the 0-1 range
#==========================================================================
# Texture class mapping function
#==========================================================================
# Re-express the PSD in terms of the International system, using an equation from Minasny et al. (2001)
intl_clay_propn <- function( usda_clay, usda_silt ) {
return( usda_clay)
}
intl_silt_propn <- function( usda_clay, usda_silt ) {
return( max( 0.0, -0.0041 - 0.127*usda_clay + 0.553*usda_silt + 0.17*usda_clay^2 - 0.19*usda_silt^2 + 0.59*usda_clay*usda_silt ) )
}
intl_sand_propn <- function( usda_clay, usda_silt ) {
return( 1.0 - intl_clay_propn( usda_clay, usda_silt ) - intl_silt_propn( usda_clay, usda_silt ) )
}
# Texture triangle as equations
texture_class <- function (usda_clay, usda_silt ) {
if(usda_clay < 0 || usda_clay > 1) stop("usda_clay should be between 0 and 1")
if(usda_silt < 0 || usda_silt > 1) stop("usda_silt should be between 0 and 1")
intl_clay <- intl_clay_propn( usda_clay, usda_silt )
intl_silt <- intl_silt_propn( usda_clay, usda_silt )
intl_sand <- 1.0 - intl_clay - intl_silt
if ((intl_sand < 0.75 - intl_clay) && (intl_clay >= 0.40)) {
class <- "silty clay"
} else if ((intl_sand < 0.75 - intl_clay) && (intl_clay >= 0.26)) {
class <- "silty clay loam"
} else if (intl_sand < 0.75 - intl_clay) {
class <- "silty loam"
} else if ((intl_clay >= 0.40 + (0.305-0.40)/(0.635-0.35) * (intl_sand-0.35)) && (intl_clay < 0.50 + (0.305-0.50)/(0.635-0.50) * (intl_sand - 0.50))) {
class <- "clay"
} else if (intl_clay >= 0.26 + (0.305-0.26)/(0.635-0.74) * (intl_sand-0.74)) {
class <- "sandy clay"
} else if ((intl_clay >= 0.26 + (0.17-0.26)/(0.83-0.49) * (intl_sand-0.49)) && (intl_clay < 0.10 + (0.305-0.10)/(0.635-0.775) * (intl_sand - 0.775))) {
class <- "clay loam"
} else if (intl_clay >= 0.26 + (0.17-0.26)/(0.83-0.49) * (intl_sand-0.49)) {
class <- "sandy clay loam"
} else if ((intl_clay >= 0.10 + (0.12-0.10)/(0.63-0.775) * (intl_sand-0.775)) && (intl_clay < 0.10 + (0.305-0.10)/(0.635-0.775) * (intl_sand - 0.775))) {
class <- "loam"
} else if (intl_clay >= 0.10 + (0.12-0.10)/(0.63-0.775) * (intl_sand-0.775)) {
class <- "sandy loam"
} else if (intl_clay < 0.00 + (0.08-0.00)/(0.88-0.93) * (intl_sand-0.93)) {
class <- "loamy sand"
} else {
class <- "sand"
}
return( class )
}
a <- AgreenaRothC(lonlat, sim_period, inp_s = 0.2, cp_b = T, cp_s = T, till_b = "Till", till_s = "Till")
devtools::document()
devtools::load_all()
devtools::install()
devtools::install()
library(AgreenaRothC)
lonlat <- c(9.302144386852655, 56.5691426133239)
sim_period <- c("2022-01-01", "2050-12-30")
wth <- get_wth_power_nasa(lonlat = lonlat, dates = dates)
dates <- c("1990-01-01", "2020-12-30")
wth <- get_wth_power_nasa(lonlat = lonlat, dates = dates)
devtools::install()
devtools::document()
devtools::install()
devtools::install()
devtools::document()
devtools::document()
detach("package:AgreenaRothC", unload = TRUE)
devtools::document()
devtools::install()
getwd()
devtools::install()
wth <- get_wth_power_nasa(lonlat = lonlat, dates = dates)
plotWth(wth)
biomass_inputs <- 1
a <- AgreenaRothC(lonlat, sim_period, inp_s = 0.2, cp_b = i, cp_s = j, till_b = "Till", till_s = "Till")
iT
i=T
j=T
a <- AgreenaRothC(lonlat, sim_period, inp_s = 0.2, cp_b = i, cp_s = j, till_b = "Till", till_s = "Till")
plotRothC(x = "baseline", a)
library(AggrenaRothC)
library(AgreenaRothC)
usethat::use_vignette("introduction")
devtools::use_vignette("introduction")
install.packages("usethat")
usethat::use_vignette("introduction")
install.packages("usethat")
library(usethat)
install.packages("usethis")
install.packages("usethis")
usethis::use_vignette("intro", "Basic example of hoe to run the model")
devtools::install()
?AgreenaRothC
??AgreenaRothC
devtools::document()
devtools::install()
??AgreenaRothC
devtools::install()
devtools::document()
devtools::install()
??Agre
sessionInfo()
devtools::document()
devtools::install()
??AgreenaRothC
