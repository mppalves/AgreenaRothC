#' @title Agreena RothC
#' @description Calculates soil carbon stocks for the RothC spin up period,
#' baseline and scenario runs.
#' @name AgreenaRothC
#' @param lonlat Longitude and latitude vector
#' @param sim_period Simulating period
#' @param inp_b Biomass inputs in the baseline scenario
#' @param inp_s Biomass inputs in the test scenario
#' @param cp_b Logical vector with months where the soil is covered. If only a
#' single value is passed the whole period will be treated homogeneously.
#' @param cp_s Logical vector with months where the soil is covered. If only a
#' single value is passed the whole period will be treated homogeneously.
#' @param till_b date ranges
#' @param till_s date ranges
#' @return returns a data frame with average (AV) and standard deviation (SD)
#' of surface temperature (TS), bias corrected precipitation (PRECTOTCORR) and
#' Evapotranspiration Energy Flux (EVPTRNS).
#' @details Agreena RothC initializes RothC biomass inputs by inverse modeling
#' to calibrate total soil carbon stocks with estimates generated by ISRIC
#' soilgrids. The estimates biomass inputs are used to spin up the model until
#' soil carbon stocks equilibrium is reached for each soil carbon compartment.
#' Those values are then used to initialize Baseline and scenario runs.
#' @author Marcos Alves
#' @import SoilR
#' @export
#'


AgreenaRothC <-
  function(lonlat,
           sim_period,
           inp_s = "same_as_base",
           cp_b = FALSE,
           cp_s = TRUE,
           till_b = c("Till", "noTill", "redTill"),
           till_s = c("Till", "noTill", "redTill"),
           soil_data = "lucas") {
    set.seed(123)
    till_b <- match.arg(till_b)
    till_s <- match.arg(till_s)

    trm_b <- switch(till_b,
      "Till" = 1,
      "noTill" = 0.95,
      "redTill" = 0.93
    )

    trm_s <- switch(till_s,
      "Till" = 1,
      "noTill" = 0.95,
      "redTill" = 0.93
    )

    # translating perior in RothC months
    years <-
      round(as.numeric(as.Date(sim_period[2]) - as.Date(sim_period[1])) / 365)
    sim_period <- seq(1 / 12, years, by = 1 / 12)
    spin_period <- seq(1 / 12, 400, by = 1 / 12)

    # downloading external input data
    wth_dates <- c("1990-01-01", "2021-12-30")

    if (soil_data == "isric") {
      soil <-
        get_isric_soil_profile_rothc(lonlat,
          statistic = "mean",
          find.location.name = FALSE
        )
    }

    if (soil_data == "lucas") {
      soil <- get_lucas_soil_profile_rothc(lonlat)
    }

    wth <-
      get_wth_power_nasa(
        lonlat = c(
          attr(soil, "meta")$Longitude,
          attr(soil, "meta")$Latitude
        ),
        dates = wth_dates
      )
    # inorganic Carbon
    iom <- 0.049 * (soil$Carbon[1]^(1.139))

    # weather distributions
    nsamples <- 5
    TS <-
      apply(wth[, c("TS_AV", "TS_SD")], 1, function(x) {
        rnorm(nsamples, x["TS_AV"], x["TS_SD"])
      })
    PR <-
      apply(wth[, c("PRECTOTCORR_AV", "PRECTOTCORR_SD")], 1, function(x) {
        rnorm(nsamples, x["PRECTOTCORR_SD"], x["PRECTOTCORR_SD"])
      })
    ET <-
      apply(wth[, c("EVPTRNS_AV", "EVPTRNS_SD")], 1, function(x) {
        rnorm(nsamples, x["EVPTRNS_AV"], x["EVPTRNS_SD"])
      })
    wth_dist <-
      array(
        c(TS, PR, ET),
        dim = c(nsamples, 12, 3),
        dimnames = list(1:nsamples, month.name, c("TS", "PR", "ET"))
      )

    # flow rate effects distribution (baseline)
    fc_b <- fC_crop_retainment(cp_b)
    ft_b <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
    fw_b <-
      t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) {
        f_moist_rothc(
          pp = x[, "PR"],
          et = x[, "ET"],
          s_thick = 30,
          pclay = mean(soil$ParticleSizeClay[1:3]),
          pE = 1.0,
          soil_cover = cp_b
        )
      }))
    colnames(fw_b) <- month.name
    fxi_b <- fw_b * ft_b * fc_b



    # flow rate effects distribution (scenario)
    fc_s <- fC_crop_retainment(cp_s)
    ft_s <- t(apply(wth_dist[, , "TS"], 1, fT.RothC))
    fw_s <-
      t(apply(wth_dist[, , c("PR", "ET")], 1, function(x) {
        f_moist_rothc(
          pp = x[, "PR"],
          et = x[, "ET"],
          s_thick = 30,
          pclay = mean(soil$ParticleSizeClay[1:3]),
          pE = 1.0,
          soil_cover = cp_s
        )
      }))
    colnames(fw_s) <- month.name
    fxi_s <- fw_s * ft_s * fc_s

    fxi_all <-
      array(
        c(fxi_b, fxi_s),
        dim = c(nsamples, 12, 2),
        dimnames = list(1:nsamples, month.name, c("baseline", "scenario"))
      )

    run_RothC <-
      function(x,
               trm_b,
               trm_s,
               inp_s,
               spin_period,
               sim_period) {
        trm_spin <- trm_b

        soilC_calib <- function(inp_calib) {
          fxi_calib <-
            data.frame(spin_period, rep(x[, "baseline"],
              length.out = length(spin_period)
            ))
          model_calib <- RothCModel(
            t = spin_period,
            c(
              k.DPM = 10 * trm_spin,
              k.RPM = 0.3 * trm_spin,
              k.BIO = 0.66 * trm_spin,
              k.HUM = 0.02 * trm_spin,
              k.IOM = 0 * trm_spin
            ),
            C0 = c(
              DPM = 0,
              RPM = 0,
              BIO = 0,
              HUM = 0,
              IOM = iom
            ),
            In = inp_calib,
            clay = mean(soil$ParticleSizeClay[1:3]),
            xi = fxi_calib
          )
          soilC_calib <- sum(as.numeric(tail(getC(model_calib), 1)))
          return((sum(soilC_calib) - soil$Carbon[1])^2)
        }

        inp_calib <- optimize(f = soilC_calib, c(0, 50))$minimum

        fxi_spin <-
          data.frame(spin_period, rep(x[, "baseline"],
            length.out = length(spin_period)
          ))
        model_spin <- RothCModel(
          t = spin_period,
          c(
            k.DPM = 10 * trm_spin,
            k.RPM = 0.3 * trm_spin,
            k.BIO = 0.66 * trm_spin,
            k.HUM = 0.02 * trm_spin,
            k.IOM = 0 * trm_spin
          ),
          C0 = c(
            DPM = 0,
            RPM = 0,
            BIO = 0,
            HUM = 0,
            IOM = iom
          ),
          In = inp_calib,
          clay = mean(soil$ParticleSizeClay[1:3]),
          xi = fxi_spin
        )
        soilC_spin_all_time <- getC(model_spin)
        soilC_spin <- as.numeric(tail(soilC_spin_all_time, 1))
        fxi_b <-
          data.frame(sim_period, rep(x[, "baseline"],
            length.out = length(sim_period)
          ))
        model_b <- RothCModel(
          t = sim_period,
          c(
            k.DPM = 10 * trm_b,
            k.RPM = 0.3 * trm_b,
            k.BIO = 0.66 * trm_b,
            k.HUM = 0.02 * trm_b,
            k.IOM = 0 * trm_b
          ),
          C0 = soilC_spin,
          In = inp_calib,
          clay = mean(soil$ParticleSizeClay[1:3]),
          xi = fxi_b
        )
        soilC_b_all_time <- getC(model_b)
        soilC_b <- as.numeric(tail(soilC_b_all_time, 1))

        if (inp_s == "same_as_base") {
          inp_s <- 0
        } else {
          if (!is.numeric(inp_s)) {
            stop(
              "inp_s must be either 'same_as_base' representing a continuation of the
              calibrated input biomass or a number representing the new biomass
              inputs"
            )
          }
        }

        fxi_s <-
          data.frame(sim_period, rep(x[, "scenario"],
            length.out = length(sim_period)
          ))
        model_s <- RothCModel(
          t = sim_period,
          c(
            k.DPM = 10 * trm_s,
            k.RPM = 0.3 * trm_s,
            k.BIO = 0.66 * trm_s,
            k.HUM = 0.02 * trm_s,
            k.IOM = 0 * trm_s
          ),
          C0 = soilC_spin,
          In = inp_calib + inp_s,
          clay = mean(soil$ParticleSizeClay[1:3]),
          xi = fxi_s
        )
        soilC_s_all_time <- getC(model_s)
        soilC_s <- as.numeric(tail(soilC_s_all_time, 1))
        res <-
          list(
            "sc_diff" = sum(soilC_s) - sum(soilC_b),
            "inp_calib" = inp_calib,
            "sc_spinup" = soilC_spin_all_time,
            "sc_baseline" = soilC_b_all_time,
            "sc_scenario" = soilC_s_all_time
          )
        return(res)
      }

    RothC_runs <-
      apply(
        fxi_all,
        1,
        run_RothC,
        trm_b = trm_b,
        trm_s = trm_s,
        inp_s = inp_s,
        spin_period = spin_period,
        sim_period = sim_period
      )

    # Cleaning up and calc statistics
    Mean_capture <- mean(unlist(sapply(RothC_runs, "[", "sc_diff")))
    Std_dev_capture <- sd(unlist(sapply(RothC_runs, "[", "sc_diff")))

    Mean_input_calib <- mean(unlist(sapply(RothC_runs, "[", "inp_calib")))
    Std_dev_input_calib <- sd(unlist(sapply(RothC_runs, "[", "inp_calib")))

    Mean_input_scenario <- inp_s


    mscc <- sapply(RothC_runs, "[", "sc_spinup")
    mscc <-
      array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
    mscc_mean <- apply(mscc, c(1, 2), mean)
    mscc_sd <- apply(mscc, c(1, 2), sd)
    mscc_stats_su <- as.data.frame(cbind(mscc_mean, mscc_sd))
    colnames(mscc_stats_su) <-
      c(
        "DPM_SU",
        "RPM_SU",
        "BIO_SU",
        "HUM_SU",
        "IOM_SU",
        "DPM_SU_SD",
        "RPM_SU_SD",
        "BIO_SU_SD",
        "HUM_SU_SD",
        "IOM_SU_SD"
      )

    mscc <- sapply(RothC_runs, "[", "sc_spinup")
    mscc <-
      array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
    mscc_total <- apply(mscc, c(1, 3), sum)
    mscc_total_mean <- apply(mscc_total, 1, mean)
    mscc_total_sd <- apply(mscc_total, 1, sd)
    mscc_stats_total_su <-
      as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
    colnames(mscc_stats_total_su) <- c("SC_SU", "SC_SU_SD")

    mscc_stats_su <- cbind(mscc_stats_su, mscc_stats_total_su)

    mscc <- sapply(RothC_runs, "[", "sc_baseline")
    mscc <-
      array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
    mscc_mean <- apply(mscc, c(1, 2), mean)
    mscc_sd <- apply(mscc, c(1, 2), sd)
    mscc_stats_b <- as.data.frame(cbind(mscc_mean, mscc_sd))
    colnames(mscc_stats_b) <-
      c(
        "DPM_B",
        "RPM_B",
        "BIO_B",
        "HUM_B",
        "IOM_B",
        "DPM_B_SD",
        "RPM_B_SD",
        "BIO_B_SD",
        "HUM_B_SD",
        "IOM_B_SD"
      )

    mscc <- sapply(RothC_runs, "[", "sc_baseline")
    mscc <-
      array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
    mscc_total <- apply(mscc, c(1, 3), sum)
    mscc_total_mean <- apply(mscc_total, 1, mean)
    mscc_total_sd <- apply(mscc_total, 1, sd)
    mscc_stats_total_b <-
      as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
    colnames(mscc_stats_total_b) <- c("SC_B", "SC_B_SD")

    mscc_stats_b <- cbind(mscc_stats_b, mscc_stats_total_b)

    mscc <- sapply(RothC_runs, "[", "sc_scenario")
    mscc <-
      array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
    mscc_mean <- apply(mscc, c(1, 2), mean)
    mscc_sd <- apply(mscc, c(1, 2), sd)
    mscc_stats_s <- as.data.frame(cbind(mscc_mean, mscc_sd))
    colnames(mscc_stats_s) <-
      c(
        "DPM_S",
        "RPM_S",
        "BIO_S",
        "HUM_S",
        "IOM_S",
        "DPM_S_SD",
        "RPM_S_SD",
        "BIO_S_SD",
        "HUM_S_SD",
        "IOM_S_SD"
      )

    mscc <- sapply(RothC_runs, "[", "sc_scenario")
    mscc <-
      array(unlist(mscc), dim = c(length(sim_period), 5, nsamples))
    mscc_total <- apply(mscc, c(1, 3), sum)
    mscc_total_mean <- apply(mscc_total, 1, mean)
    mscc_total_sd <- apply(mscc_total, 1, sd)
    mscc_stats_total_s <-
      as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
    colnames(mscc_stats_total_s) <- c("SC_S", "SC_S_SD")

    mscc_stats_s <- cbind(mscc_stats_s, mscc_stats_total_s)

    mscc <- sapply(RothC_runs, "[", "sc_spinup")
    mscc <-
      array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
    mscc_mean <- apply(mscc, c(1, 2), mean)
    mscc_sd <- apply(mscc, c(1, 2), sd)
    mscc_stats_su <- as.data.frame(cbind(mscc_mean, mscc_sd))
    colnames(mscc_stats_su) <-
      c(
        "DPM_SU",
        "RPM_SU",
        "BIO_SU",
        "HUM_SU",
        "IOM_SU",
        "DPM_SU_SD",
        "RPM_SU_SD",
        "BIO_SU_SD",
        "HUM_SU_SD",
        "IOM_SU_SD"
      )

    mscc <- sapply(RothC_runs, "[", "sc_spinup")
    mscc <-
      array(unlist(mscc), dim = c(length(spin_period), 5, nsamples))
    mscc_total <- apply(mscc, c(1, 3), sum)
    mscc_total_mean <- apply(mscc_total, 1, mean)
    mscc_total_sd <- apply(mscc_total, 1, sd)
    mscc_stats_total_su <-
      as.data.frame(cbind(mscc_total_mean, mscc_total_sd))
    colnames(mscc_stats_total_su) <- c("SC_SU", "SC_SU_SD")

    res <-
      list(
        "Longitude final" = attr(soil, "meta")$Longitude,
        "Latitude final" = attr(soil, "meta")$Latitude,
        "Soil type" = attr(soil, "meta")$SoilType,
        "Ini. SOC" = soil$Carbon[1],
        "Mean 30cm clay %" = mean(soil$ParticleSizeClay[1:3]),
        "Mean TS" = colMeans(wth[, "TS_AV"]),
        "Mean PR" = colMeans(wth[, "PRECTOTCORR_AV"]),
        "Mean ET" = colMeans(wth[, "EVPTRNS_AV"]),
        "Mean_input_calib" = Mean_input_calib,
        "Std_dev_input_calib" = Std_dev_input_calib,
        "Mean_input_scenario" = Mean_input_scenario,
        "Mean_capture" = Mean_capture,
        "Std_dev_capture" = Std_dev_capture,
        "soilC_spinup" = mscc_stats_su,
        "soilC_baseline" = mscc_stats_b,
        "soilC_scenario" = mscc_stats_s
      )

    alist <- list()
    alist$Longitude <- attr(soil, "meta")$Longitude
    alist$Latitude <- attr(soil, "meta")$Latitude
    alist$ini_Longitude <- attr(soil, "meta")$ini_Longitude
    alist$ini_Latitude <- attr(soil, "meta")$ini_Latitude
    alist$ini_SOC <- soil$Carbon[1]
    alist$Unit_SOC <- "C Mg/ha"
    attr(res, "meta") <- alist

    return(res)
  }
